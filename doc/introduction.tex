\chapter{Introduction}
\label{chap:intro}
In the field of robotics, the most common task beyond pure observation is to find specific objects. It is an integral part of almost everything a robot that interacts with its environment does, because it first needs to know where things are in order to manipulate them. It has to move and look around for every item it is going to use everytime before doing anything else. This only works well when operating in small areas a robot can cover relatively fast. In larger areas search can quickly become the activity that the robot spends most of its time on. \\

One solution is to define a location for every object the robot has to deal with, which then can be provided with a list of these locations, thus enabling it to simply look up an objects position and eliminating the need for search completely. This approach is often employed in static environments. A common use-case is a warehouse, which is already organised in a way that all of its contents have their specific place.

While this approach is much faster than searching for everything as needed, it is also very unflexible. It requires a complex setup and previous knowledge about the domain the robot is going to work in. It is unable to deal with dynamic changes to the world, like objects changing their position, unless the user keeps manually entering information. \\

The goal of this work is to create a method that enables a robot to quickly find objects, while retaining the flexibility of a dynamic approach. It will need to be able to recognize objects that might become relevant in the future and remember their position, creating a map of its environment which is able to reflect changes to the world.

In order to accomplish this goal, the robot will still need to be provided with a list of potentially interesting objects. The difference is, that this list has to contain some basic information needed to identify these objects (i.e. what they look like) only. This information will not change over time and therefore does not require maintenance.

While the robot is executing other tasks, it can watch out for the more prominent features of given objects. In order not to interfere with its current assignment, the robot will only investigate further if something comes up in this process. Successfully recognized objects will be memorized in association with their position. Then, when a specific object is needed, the robot knows where the nearest one is most likely to be found. \\

The system will be tested and presented in a shopping scenario, where a robot is supposed to find objects from a shopping list in a supermarket. A shopping scenario is a good example to illustrate the benefits of the method proposed in this work, because a supermarket does arrange goods by grouping them by category and keeps them in roughly the same place over longer periods of time, but it does not provide a list of specific locations for third-parties to use to locate objects. Maintaining a list of locations for a shopping robot manually would require a lot of work, because supermarkets tend to switch things around slightly. \\

Since perceiving arbitrary objects is a whole field of study on its own, this work will focus on packaged supermarket goods, which is sufficient in the context of this scenario as well as for the purpose of demonstrating the method at hand.

\section{Structure}
This document details multiple applications that compose a system capable of
\begin{itemize}
  \itemsep 0em
  \item maintaining a set of objects a robot is dealing with
  \item detecting these objects with a camera and laser sensor
  \item memorising detected objects for later use
  \item and evaluating their relevance to a situation
\end{itemize}
as a means to meet the goal set in section~\ref{chap:intro}: To create a method that combines the advantages of two very different approaches to finding objects. The system is described from its conception to its realisation and analyzed in regards to whether the goal was achieved by this work. \\

First, subsystems are identified that are necessary to provide the specified functionality. Interfaces are defined for these subsystems to communicate with each other, to supply each other with the information they contribute to the end result. This is followed by a description of the implementation of the resulting architecture, which covers the techniques used to realise the responsibilities of the subsystems and to put them together. The implementation is then put to test in the supermarket scenario mentioned in Section~\ref{chap:intro} to review the techniques used in the implementation and to assess the proposed method for finding objects. In a critical discussion, the results of the analysis are examined, to determine the success of this work and to draw a conclusion. Finally, the document gives an outlook on additional functionality to be build upon this work.
